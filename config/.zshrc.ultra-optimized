# ===============================================
# Ultra-Optimized ZSH Configuration - Development Environment
# ===============================================
# Version: 2.0 (Ultra Performance Optimized)
# Maintainer: dev-env project
# ===============================================

# Enable Powerlevel10k instant prompt (only in normal mode)
# Note: Use quiet mode in tmux to suppress warnings about console output
if [[ "$FAST_MODE" != "true" ]]; then
  if [[ -n "$TMUX" ]]; then
    typeset -g POWERLEVEL9K_INSTANT_PROMPT=quiet
  fi

  if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
    source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
  fi
fi

# Collapse nested launcher shells by exiting the previous instance when reopened.
if [[ -n "$ZSH_LAUNCHER_ACTIVE" ]]; then
    trap 'builtin exit' USR1
    if [[ -n "$ZSH_LAUNCHER_PREV_PID" && "$ZSH_LAUNCHER_PREV_PID" != "$$" ]]; then
        if kill -0 "$ZSH_LAUNCHER_PREV_PID" 2>/dev/null; then
            kill -USR1 "$ZSH_LAUNCHER_PREV_PID" 2>/dev/null || true
        fi
        unset ZSH_LAUNCHER_PREV_PID
    fi
fi

# ===============================================
# Performance Optimizations First
# ===============================================

# Skip compinit for faster startup - will be loaded on demand
SKIP_COMPINIT=true

# Fast startup mode
if [[ "$1" == "--fast" ]]; then
    echo "🚀 Fast mode enabled - skipping heavy initialization"
    FAST_MODE=true
else
    FAST_MODE=false
fi

# ===============================================
# Antigen Plugin Manager - Lazy Loading
# ===============================================

# Only load Antigen if not in fast mode
if [[ "$FAST_MODE" != "true" ]]; then
    source "$HOME/.antigen.zsh"
    antigen use oh-my-zsh

    # Core Plugins Only
    antigen bundle git

    # Apply settings
    antigen theme romkatv/powerlevel10k
    # Note: Suppress output to prevent instant prompt warnings
    antigen apply &>/dev/null
else
    # Fast mode - minimal setup
   autoload -U colors && colors
    PROMPT="%{$fg[green]%}%n@%m%{$reset_color%}:%{$fg[blue]%}%~%{$reset_color%}$ "
fi

# ===============================================
# Python Environment
# ===============================================

# Use Python 3 by default
alias python=python3
alias pip=pip3

# Conda Environment - Lazy Loading
if [[ -f "$HOME/anaconda3/etc/profile.d/conda.sh" ]]; then
    export CONDA_EXE="$HOME/anaconda3/bin/conda"
    export _CONDA_ROOT="$HOME/anaconda3"
    alias conda-init="eval \"\$($HOME/anaconda3/bin/conda shell.zsh hook)\" && conda activate base"
fi

# NVM - Lazy Loading
export NVM_DIR="$HOME/.nvm"
alias nvm-lazy='[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" && [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"'

# ===============================================
# FZF Configuration
# ===============================================

# Enable FZF
[ -f ~/.fzf.zsh ] && source ~/.fzf.zsh

# FZF Configuration - Simplified
export FZF_DEFAULT_COMMAND='fdfind --hidden --follow -E ".git" -E "node_modules" . /etc /home'
export FZF_DEFAULT_OPTS='--height 90% --layout=reverse --bind=alt-j:down,alt-k:up --border'

# ===============================================
# Development Tools
# ===============================================

# CUDA & TensorRT
export LD_LIBRARY_PATH=/usr/local/cuda-11.1/lib64/:/usr/local/TensorRT/targets/x86_64-linux-gnu/lib/:$LD_LIBRARY_PATH
export PATH=/usr/local/cuda-11.1/bin/:$PATH

# Autojump - Lazy Loading (ultra-optimized)
# NOTE: CRITICAL FIX - j() must use 'cd' to actually change directories!
#       Just calling autojump returns directory path but doesn't change to it.
#
# OPTIMIZATION: Use one-time loading flag to avoid redundant initialization
typeset -g _AUTOJUMP_LAZY_LOADED=0

lazy_load_autojump() {
    # Skip if already loaded
    [[ $_AUTOJUMP_LAZY_LOADED -eq 1 ]] && return 0

    if [[ -s "$HOME/.autojump/etc/profile.d/autojump.sh" ]]; then
        source "$HOME/.autojump/etc/profile.d/autojump.sh"
        # autojump.zsh provides proper j() function with cd integration
    elif command -v autojump &> /dev/null; then
        [[ -s "$(dirname $(command -v autojump))/../share/autojump/autojump.sh" ]] && \
            source "$(dirname $(command -v autojump))/../share/autojump/autojump.sh"
    else
        # autojump not available - keep placeholder functions
        return 1
    fi

    _AUTOJUMP_LAZY_LOADED=1
}
alias autojump-init='lazy_load_autojump'

# Ultra-optimized j() - lazy load autojump and jump to directory
# FIXED: Avoid function override conflict by checking if autojump.zsh's j() was loaded
j() {
    # First-time initialization
    if [[ $_AUTOJUMP_LAZY_LOADED -eq 0 ]]; then
        lazy_load_autojump

        # If autojump.zsh successfully defined j(), delegate to it
        if typeset -f j | grep -q "autojump"; then
            # Undefine this wrapper and call the real j() from autojump.zsh
            unfunction j
            j "$@"
            return $?
        fi
    fi

    # Fallback implementation if autojump.zsh's j() is not available
    if command -v autojump &> /dev/null; then
        local target_dir="$(autojump "$@" 2>/dev/null)"
        if [[ -d "$target_dir" ]]; then
            cd "$target_dir" && echo "📂 $target_dir"
        else
            echo "autojump: directory '$*' not found" >&2
            return 1
        fi
    else
        echo "❌ autojump is not installed" >&2
        echo "Install with: apt-get install autojump (Ubuntu/Debian) or brew install autojump (macOS)" >&2
        return 1
    fi
}

jhistory() {
    # Initialize autojump if not already loaded
    [[ $_AUTOJUMP_LAZY_LOADED -eq 0 ]] && lazy_load_autojump

    if command -v autojump &> /dev/null; then
        autojump -s "$@" 2>/dev/null || return 1
    else
        echo "❌ autojump is not installed" >&2
        return 1
    fi
}

# ===============================================
# Custom Functions
# ===============================================

# Load custom functions from ~/.zsh/functions
if [[ -d "$HOME/.zsh/functions" ]]; then
    for function_file in "$HOME/.zsh/functions"/*.zsh; do
        if [[ -f "$function_file" ]]; then
            source "$function_file"
        fi
    done
fi

# ===============================================
# Completion System - Lazy Loading
# ===============================================

# Cached compinit helper
_dev_env_cached_compinit() {
    setopt LOCAL_OPTIONS EXTENDED_GLOB
    autoload -Uz compinit
    zmodload zsh/stat 2>/dev/null || true

    local cache_root="${XDG_CACHE_HOME:-$HOME/.cache}/dev-env"
    local dump_file="${cache_root}/zcompdump-${HOST}-${ZSH_VERSION}"
    local dump_ttl=${ZSH_COMPDUMP_TTL:-86400}

    [[ -d "${cache_root}" ]] || mkdir -p "${cache_root}"

    local -a compinit_args
    compinit_args=(-d "${dump_file}")

    if [[ -s "${dump_file}" ]]; then
        local -a dump_stat
        if zstat -A dump_stat +mtime -- "${dump_file}" 2>/dev/null; then
            if (( EPOCHSECONDS - dump_stat[1] < dump_ttl )); then
                compinit_args=(-C "${compinit_args[@]}")
            fi
        fi
    fi

    if [[ "${compinit_args[1]}" != "-C" ]]; then
        local -a insecure_dirs
        insecure_dirs=(${(@f)$(compaudit 2>/dev/null)})
        if (( ${#insecure_dirs} )); then
            compinit_args=(-i "${compinit_args[@]}")
        fi
    fi

    compinit "${compinit_args[@]}"
}

# Function to enable completion on demand
enable_completion() {
    if [[ -z "$COMPLETION_ENABLED" ]]; then
        echo "🔄 Enabling ZSH completion system..."
        _dev_env_cached_compinit

        # Case-insensitive Tab completion (safe and convenient)
        zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}'

        COMPLETION_ENABLED=true

        # Load Antigen completion plugins if available
        if [[ "$FAST_MODE" != "true" ]] && command -v antigen &>/dev/null; then
            antigen bundle zsh-users/zsh-completions
            antigen bundle zsh-users/zsh-autosuggestions
            antigen bundle zsh-users/zsh-syntax-highlighting
            antigen apply &>/dev/null
        fi
        echo "✅ Completion system enabled"
    fi
}

# Auto-enable completion when first tab is pressed
lazy_completion() {
    enable_completion
    zle expand-or-complete
}
zle -N lazy_completion

# Bind tab to lazy completion only if completion not enabled
if [[ -z "$COMPLETION_ENABLED" ]]; then
    bindkey '^I' lazy_completion
fi

# ===============================================
# Additional Aliases
# ===============================================

# Point Cloud Tools
alias pm="pcl_viewer -use_point_picking -ax 4 -multiview 1"
alias pa="pcl_viewer -ax 4 -use_point_picking"

# Quick completion enable
alias comp-enable='enable_completion'

# ===============================================
# Environment Variables
# ===============================================

# Google Cloud Project
export GOOGLE_CLOUD_PROJECT="gen-lang-client-0165913056"

# ===============================================
# Performance Monitoring
# ===============================================

# Function to measure startup time
zsh_benchmark() {
    local start_time=$(date +%s.%N)
    zsh -i -c 'exit' 2>/dev/null
    local end_time=$(date +%s.%N)
    local duration=$(echo "$end_time - $start_time" | bc -l)
    echo "ZSH startup time: ${duration}s"
}

# ===============================================
# Powerlevel10k Configuration
# ===============================================

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
if [[ "$FAST_MODE" != "true" ]]; then
    [[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh
fi

# ===============================================
# Configuration Complete
# ===============================================

# Welcome message disabled to support Powerlevel10k instant prompt
# Uncomment to re-enable:
# if [[ "$FAST_MODE" == "true" ]]; then
#     echo "⚡ Ultra-Fast ZSH Configuration Loaded (Fast Mode)"
# else
#     echo "🚀 Ultra-Optimized ZSH Configuration Loaded"
#     echo "💡 Type 'comp-enable' to enable command completion"
# fi

# ===============================================
# User-Local Binary PATH (~/.local/bin)
# ===============================================
# Add ~/.local/bin to PATH for user-installed tools (e.g., uv, pipx, etc.)
# This script uses intelligent PATH management to avoid duplicate entries
# Source: uv installer and XDG Base Directory Specification
if [[ -f "$HOME/.local/bin/env" ]]; then
    source "$HOME/.local/bin/env"
fi
